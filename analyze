#!/usr/bin/env ruby
require 'nokogiri'
require 'date'
require 'active_support'
require 'active_support/core_ext/date_time'
require 'pry'

# launch model structs

Payload = Struct.new(:name, :country, :operator, :orbit, :function, :decay, :outcome)
Rocket = Struct.new(:name, :country)
LaunchSite = Struct.new(:name, :country)
LaunchServiceProvider = Struct.new(:name, :country)
Launch = Struct.new(:date, :rocket, :launch_site, :lsp, :payloads, :remarks)

def analyze year
  html = Nokogiri::HTML IO.read "wiki/#{year}.html"

  # find the main table
  table = html.css('table.wikitable').find { |table|
    table.css('tr').first.to_s.match /Rocket.*Launch site.*LSP/m
  }

  # ignore header and month dividers
  rows = table.css('tr').drop(3).reject { |row| row.at_css('td')['colspan'] == "7" }

  # group rows by launch
  launches_html = []
  rows.each_with_index { |row, index|
    if (rowspan = row.at_css('td')['rowspan'].to_i) > 0
      launches_html << rows[index...index+rowspan]
    end
  }

  # parse launch data

  def flags cell
    cell.css('.flagicon > a').map { |a| a['title'] }
  end

  launches = []
  launches_html.each do |rows|
    info_row = rows[0]
  
    begin
      date = DateTime.parse(info_row.css('td')[0].content)
      date = date.change(year: year)
    rescue ArgumentError
      puts 'Bad date, skipping' 
      next
    end
  
    if date > DateTime.now
      puts 'Future date, stopping for the year'
      break
    end
  
    rocket_name = info_row.css('td')[1].content.strip
    rocket_country = flags(info_row.css('td')[1])
    rocket = Rocket.new(rocket_name, rocket_country)
  
    launch_site_name = info_row.css('td')[2].content.strip
    launch_site_country = flags(info_row.css('td')[2])
    launch_site = LaunchSite.new(launch_site_name, launch_site_country)
  
    lsp_name = info_row.css('td')[3].content.strip
    lsp_country = flags(info_row.css('td')[3])
    lsp = LaunchServiceProvider.new(lsp_name, lsp_country)
  
    # puts date.strftime('%e %b %Y %H:%M')
    # puts rocket
    # puts launch_site
    # puts lsp
  
    rows.shift
  
    if last_cell = rows.last.css('td')[0] and last_cell['colspan'] == '6'
      remarks = last_cell.content
      rows.pop
    end
    
    # rewrite rows so that merged rows get duplicated
    rows = rows.map do |row|
      td = row.css('td')
      Array(td[0...td.count])
    end
    
    new_rows = rows.map { |r| r.dup }
    
    rows.each_with_index do |row, i|
      row.each_with_index do |cell, j|
        rowspan = cell["rowspan"].to_i
        if rowspan > 1
          # puts "doing it, #{i}x#{j}"
          # puts rows[i][j]
          (i+1...i+rowspan).each do |r|
            # puts "Replacing #{r}x#{j}"
            new_rows[r].insert j, cell.dup
          end
        end
      end
    end
    
    # analyze payloads
  
    payloads = new_rows.map do |sat|
      name     = sat[0].content.strip
      country  = flags(sat[0])
      operator = sat[1].content.strip
      orbit    = sat[2].content.strip
      function = sat[3].content.strip
      decay    = sat[4].content.strip
      outcome  = sat[5] && sat[5].content.strip
      payload  = Payload.new(name, country, operator, orbit, function, decay, outcome)
      # puts payload
      payload
    end
  
    # puts remarks
    # puts
  
    launches << Launch.new(date, rocket, launch_site, lsp, payloads, remarks)
  end

  launches.reject! &:nil?
  puts "#{launches.count} launches in #{year}"
  launches
end

# analyze all years

# years = (1951..Time.now.year)
skip = [1991, 2008, 2009, 1960, 1961, 1962, 1963, 1964, 1965] # split pages
skip += [1998] # wiki-side formatting error
skip += [1972, 1974, 1967, 1969] # unsupported formatting
years = Array(1951..Time.now.year) - skip

all_launches = years.flat_map do |year|
  puts "Analyzing data for #{year}..."
  analyze year
end

# launches = analyze 2014

# binding.pry

# exporting

require 'json'

class Struct
  def to_map
    map = Hash.new
    self.members.each { |m| map[m] = self[m] }
    map
  end

  def to_json(*a)
    to_map.to_json(*a)
  end
end

# IO.write '2015.json', JSON.pretty_generate(launches)